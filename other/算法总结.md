# 算法总结

## 链表总结

1. 利用 dummy节点统一删除头节点和中间节点的逻辑
2. 查找倒数第n个节点
   - 快慢指针法，快指针先走 n 步，慢指针再走，等快指针走到底时，慢指针即为删除的前置节点
   - 利用栈先进后出，先全部进栈，再依次弹出 n 个节点，栈顶即为删除的前置节点
3. 删除节点时需要考虑操作节点指针之间的顺序

## 哈希表

1. 数值比较小且连贯时，可以用数组下标来作为哈希表
2. 使用 set，map 来做哈希表每次 set 值的时候需要对 key 进行 hash 处理，此时对比数组直接用下标会有额外的性能开销

## 字符串

1. 大部分字符串都依靠双指针解决。
2. 少部分可以利用栈和队列的数据结构以及 KMP 算法来处理。

## 单调队列

### 底层存储

1. 单调队列也叫优先级队列，底层其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系

### 单调队列应用场景

1. 滑动窗口极值问题​​：当需要在一个​​滑动窗口​​中快速获取最大值或最小值时，单调队列可以在 O(1) 时间返回极值。例如：
   - 窗口滑动时，移除窗口外的旧元素，保持队列头部始终是当前窗口的极值。
   - 每次新元素入队时，删除队列中比当前元素小（或大）的元素，保持单调性。
2. ​子数组问题优化​​：当问题涉及寻找满足特定条件的子数组（如最短长度、最长长度、区间和限制等），单调队列可以结合​​前缀和​​等技巧，快速判断子数组的合法性。
3. ​​动态规划优化​​：在动态规划问题中，如果状态转移方程需要从某个区间内获取极值，单调队列可以将时间复杂度从 O(n) 优化到 O(1)。

### LeetCode 中常见的单调队列题型​​

​1. ​滑动窗口极值​​  

- 239.滑动窗口最大值（模板题，必刷）
- 剑指 Offer 59 - II. 队列的最大值

​2. ​子数组和的最短/最长问题​​

- 862.和至少为 K 的最短子数组（结合前缀和 + 单调队列）
- 209.长度最小的子数组（暴力超时时可用单调队列优化）

​3. ​其他区间极值问题​​

- 1438.绝对差不超过限制的最长连续子数组（维护两个单调队列，分别存最大值和最小值）

### ​单调队列的实现要点​​

​1. ​队列中存储索引​​（而非直接存储数值），便于判断元素是否在窗口内。
​2. ​维护单调性​​：插入新元素前，从队列尾部删除破坏单调性的元素。
​3. ​删除过期元素​​：窗口滑动时，检查队首元素是否超出窗口范围，若超出则移除。

## 单调栈

## 二叉树

### 种类

1. 满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。
2. 完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，同时最底层节点从左到右依次排列。
3. 二叉搜索树：二叉搜索树是一个有序树。
   - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
   - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
   - 它的左、右子树也分别为二叉排序树。
4. 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
   - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn；
   - unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

### 存储方式

1. 链式存储：通过用链表指针的形式把分布在各个地址的节点串联一起。
2. 顺序存储：通过用数组的形式顺序存储，其元素在内存是连续分布的。父节点的数组下标是 i，那么它的左孩子就是 `i *2 + 1`，右孩子就是 `i* 2 + 2`

### 遍历方式

1. 深度优先搜索（前中后，其实指的就是中间节点的遍历顺序）
   - 前序遍历（递归法[底层是 函数调用栈]，迭代法[利用栈模拟递归]）
   - 中序遍历（递归法，迭代法）
   - 后序遍历（递归法，迭代法）
   - [DFS遍历方式](https://peigo.top/engineer-basic/structure-algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84DFS.html#%E8%BF%AD%E4%BB%A3%E6%B3%95%E5%92%8C%E9%80%92%E5%BD%92%E6%B3%95%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84dfs)
2. 广度优先搜索
   - 层次遍历（迭代法[利用队列]）

## 递归三步曲

1. 确定递归终止条件
2. 确定递归的参数和返回值
3. 确定单层递归的逻辑

## 回溯算法

 回溯算法是一种暴力搜索的思想，通常回溯过程发生在递归函数的下一步。

### 回溯算法应用场景

1. 数组组合问题
2. 数组排列问题（排列强调顺序，组合不强调顺序）
3. 字符串切割问题
4. 数组求子集问题
   - 每个元素都可以 选｜不选，背包问题也是一种子集型回溯
5. 棋盘问题（N 皇后问题、解数独问题）

### 回溯算法模版

1. 回溯算法一般是在集合中递归搜索，并且解决的问题都可以抽象为一颗树形结构，其中集合的大小构成了树的宽度，递归的深度构成的树的深度。
![backtracking](image.png)

```text
function backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 关于去重

1. 去重前需要判断是否应该对集合排序
2. 树层上在 for 循环前可以用 set 来去重，每次递归重新声明。
3. 树枝去重（排列问题）需要用 visited 数组传入递归函数中去重。

```text
function backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    // 声明 set 来做树层去重
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
         if (set.has(选择)) {
               continue; // 树层去重
         }

         // 基于数组排序前提下，判断当前节点和上一个节点值相同
         if (当前节点和上一个节点值相同 && visited[上一节点] == false) {
               continue; // 树枝去重
         }

        处理节点;
        visited[选择] = true; // 处理节点
        backtracking(路径，visited, 选择列表); // 递归
        回溯，撤销处理结果
      visited[选择] = false; // 回溯
    }
}
```

## 贪心算法

1. 贪心算法是从局部最优解出发，推导出全局最优解的一种算法设计思想。
2. 在做贪心算法类题目时可以通过思考每个阶段的局部最优解是什么？局部最优能否推出全局最优。至于如何思考局部最优，更多是通过分析题目以及反证法的思路来进行推导。

### 难点题目

135.分发糖果
406.根据身高重建队列
763.划分字母区间
738.单调递增的数字
968.监控二叉树

## 动态规划

动态规划是一种将复杂问题分解为更简单的子问题的算法设计方法。它通过存储子问题的解来避免重复计算，从而提高效率。

### 动态规划的应用场景

1. 动规基础问题：斐波那契、爬楼梯
2. 背包问题
3. 打家劫舍问题
4. 股票买卖问题
5. 子序列问题：最长递增子序列、字符串编辑最小距离
6. 区间DP、概率 DP（难度过高不考虑）

### 动态规划思路拆解5步

1. DP 数组以及下标 的含义
2. 递推公式（状态转移方程）
3. DP 数组如何初始化以及边界条件
4. 遍历顺序（从小到大还是从大到小、背包问题先遍历背包还是先遍历物品）
5. 打印DP数组的变化过程（作为调试依据）

### 背包问题

#### 背包类型

1. 01 背包：n 种物品，每种物品只能选一次
2. 完全背包：n 种物品，每种物品可以选多次
3. 多重背包(不考虑)：n 种物品，每种物品个数各不相同

### 01 背包

有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

基本信息如下：
![alt text](image-2.png)

#### dp数组的含义

`dp[i][j]` : 下标 0-i 的物品任取放入容量为 j 的背包中，能获得的最大价值

### 递推公式

01 背包因为物品只能放入 1 次，所以可以先遍历每个物品，每个物品的状态为放入背包和不放入背包（也可以先遍历背包容量，从小到大依次递减，判断是否放入对应容量大小物品）。此时状态转移方程为：

```js
// 不放入物品 i，背包重量和价值不变: dp[i][j] = dp[i-1][j]
// 放入物品 i，背包重量减去物品 i 重量，价值增加物品 i 价值: dp[i][j] = dp[i-1][j-weight[i]] + value[i]
dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i])
```

### dp数组初始化和遍历顺序

由递推公式可知：`dp[i][j]` 的状态依赖于 `i-1` 和 `j-weight[i]`， 也就是依赖左边和上边，所以遍历顺序应该从左到右，从上到下。确保每个状态都能在使用前被计算出来。此时我们需要先初始化第一行状态:

1. `dp[0][j] = j >= weight[0] ? value[0] : 0` : 取决于背包容量 j 是否能放入物品 0（因为同个物品只能放入 1 次所以最大价值为物品 0 的价值），最大价值也为 0（不能放入）或者 value[0](能放入) 。
此时dp 数组初始化情况如下：
![alt text](image-1.png)

### 二维DP 数组模版

```js
// 1. 初始化二维数组为 0
// 2. 因为依赖上一行 i-1 的状态，所以需要初始化第一行。
// 遍历背包容量，从大于等于物品0 开始，背包价值为物品0 的价值
for (let j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
// weight数组的大小 就是物品个数
// 01 背包二维数组两个 for 循环先遍历物品和先遍历背包都是可以的。不影响状态转移
for(let i = 0; i < weight.length; i++) { // 遍历物品
   for(let j = 0; j <= bagweight; j++) { // 遍历背包容量
      if (j < weight[i]) {
         // 背包容量小于物品 i 的重量，不能放入物品 i
         // 此时最大价值和不放入物品 i 一样,不考虑放入物品 i ，避免数组下标 j - weight[i]为负数
         dp[i][j] = dp[i - 1][j]
      }else{
         dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])
      };

   }
}
```

### dp数组降维

1. 由递推公式可知：不论是放入物品 i 还是不放入物品 i ，`dp[i][j]` 的状态都只依赖于 `dp[i-1]` 的状态，所以可以将 dp 数组由二维数组降维为一维数组。只维护 dp[i-1] 层的状态即可。
2. 此时 dp[j] 的含义即为：容量为 j 的背包能获得的最大价值。
3. 递推公式变为：`dp[j] = max(dp[j], dp[j-weight[i]] + value[i])`。 此时状态依赖 `dp[j-weight[i]]`，所以我们要考虑 dp[0] 的状态（这里 dp[0] 初始化状态表示背包容量 0，物品数量也为 0，也就是二维数组`dp[0][0]`的情况，并非是说考虑放入物品 0 第一行的最大价值，因为后续遍历时会不断更新dp[0]（j - weight[i]为 0） ，此时才是放入物品 0 时（对应二维第一行）的状态。）。
4. 一维数组模版

```js
// 1. 初始化一维数组为 0
let dp = new Array(bagweight + 1).fill(0);
// 2. 遍历背包容量，一维数组中我们只需要考虑 dp[0]的状态。非 0 下标由于 dp[j] = max(dp[j], dp[j - weight[i]] + value[i])且背包是倒序遍历的，不依赖 dp[i-1] 的状态，所以我们不需要像二维一样先初始化物品 0 的情况。
dp[0] = 0; // 当背包容量为 0 时，放满背包的最大价值为 0，所以这里也可以省略。但是算排列组合问题时这里需要初始化 dp[0] = 1;，表示背包容量为0的方法数为 1，即不放物品
// 3. 遍历物品，一维数组只能先遍历物品再遍历背包。否则背包的最大价值记录的都只会是某一个物品的最大价值了
for(let i = 0; i < weight.length; i++) { // 遍历物品
   // 4. 遍历背包容量，为了保证遍历背包容量时上一层的状态dp[j - weight[i]]不被覆盖，需要从大到小遍历背包容量。也可以理解倒序可以保证每个物品只被添加一次。
   for(let j = bagweight; j >= weight[i]; j--) { 
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
   }
}
```

### 01背包解决排列组合

有n件物品和一个最多能背重量为w 的背包。每个物品可以放入 1 次，求放满背包的方法有几种。

#### 二维DP数组版本

1. 二维 DP 数组的含义：`dp[i][j]` 表示 0-i 个物品放入容量为 j 的背包的总方法。
2. 递推公式：`dp[i][j] = dp[i-1][j] + dp[i-1][j-weight[i]]`。即不放入物品 i 时放满背包容量 j 的方法数 + 放入物品 i时放满背包容量（此时背包容量为 j-weight[i] ）的方法数。
3. dp 数组初始化和遍历顺序：由递推公式可知，我们需要先初始化最上边行的状态（同 01 背包基础）。
   - 初始化第一行：`dp[0][i]`状态：当且仅当背包容量i等于物品 0 的重量时，放满背包的方法数为 1（即此时放入物品 0），否则为 0。
4. 二维 DP 数组模版

```js
// 1. 初始化二维数组为 0
let n = weight.length
let dp = new Array(n).fill(0).map(() => new Array(bagweight + 1).fill(0));
// 2. 初始化第一行和第一列
// 初始化第一行，
// 不放物品 0
dp[0][0] = 1;
// 放物品 0，防止数组下标溢出，加个判断
if (weight[0] <= bagweight) {
   // 只考虑物品 0 的情况下，当且仅当背包容量等于物品 0 的重量时，放满背包的方法数为 1，否则为 0
    dp[0][weight[0]] = 1;
}

// 3. 遍历物品和背包容量，二维数组先遍历物品还是背包都可以，背包遍历顺序正反也都可以
for (let i = 1; i < n; i++) { // 遍历物品
    for (let j = 1; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) {
            dp[i][j] = dp[i - 1][j]; // 背包容量小于物品 i 的重量，不能放入物品 i
        } else {
            dp[i][j] = dp[i - 1][j] + dp[i - 1][j - weight[i]]; // 放入物品 i 和不放入物品 i 的方法数
        }
    }
}
```

#### 一维DP数组版本

1. 一维 DP 数组的含义：`dp[j]` 表示放入容量为 j 的背包的总方法数。
2. 递推公式：`dp[j] = dp[j] + dp[j-weight[i]]`。即不放入物品 i 时放满背包容量 j 的方法数 + 放入物品 i时放满背包容量（此时背包容量为 j-weight[i] ）的方法数。
3. dp 数组初始化和遍历顺序：由递推公式可知，我们需要先初始化dp[0]的状态（背包容量为 0，不放任何物品）
4. 一维数组递推公式也可以这样理解，dp[j] 的总方法拆解为：
   - 背包里面包含物品 0 的方法：dp[j - weight[0]](放入物品 0 时的方法数)
   - 背包里面包含物品 1 的方法：dp[j - weight[i]] (放入物品 1 时的方法数)
   - ...
   - 背包里面包含物品 n 的方法：dp[j - weight[n]] (放入物品 n 时的方法数)
   - 总的方法则是以上所有方法的和：dp[j] += dp[j - nums[i]];
5. 一维 DP 数组模版  

```js
// 1. 初始化一维数组为 0
let dp = new Array(bagweight + 1).fill(0);
// 2. 考虑背包容量为 0，物品 0 个的情况，即不放任何物品此时重量为 0，为 1 种方法（ 01 背包基础的差异点）
dp[0] = 1; 
// 3. 遍历物品和背包容量，一维数组先遍历物品再遍历背包
for (let i = 0; i < weight.length; i++) { // 遍历物品
   // 4. 遍历背包容量，为了保证遍历背包容量时上一层的状态dp[j - weight[i]]不被覆盖，需要从大到小遍历背包容量。也可以理解倒序可以保证每个物品只被添加一次。
   for (let j = bagweight; j >= weight[i]; j--) { 
      dp[j] += dp[j - weight[i]];
   }
}
```

### 完全背包

有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。

#### 完全背包模板（1 维数组）

```js
// 1. 初始化一维数组为 0
let dp = new Array(bagweight + 1).fill(0);
// 2. 考虑背包容量为 0，物品 0 个的情况
dp[0] = 0;
// 3. 遍历物品和背包容量，一维数组先遍历物品(完全背包问题也可以先遍历背包再遍历物品)
for (let i = 0; i < weight.length; i++) { 
   // 4. 遍历背包容量，完全背包物品可以被重复加入，所以要利用当前行的状态，也就是背包容量要正序遍历（与 01 背包的区别点）
   for (let j = weight[i]; j <= bagweight; j++) { 
      dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
   }
}
```

#### 完全背包解决排列组合问题

有n件物品和一个最多能背重量为w 的背包。每个物品可以放入多次，求放满背包的方法有几种。

1. 这里一维递推公式和 01 一样，都是 `dp[j] += dp[j - weight[i]]`。
2. 初始化时: 需要考虑 dp[0] 状态（一般 dp[0] = 1）
3. 遍历顺序: 需要注意的是求方法数是排列还是组合：
   - 如果是组合问题（即物品放入顺序不同也属于同一种方法），则**需要先遍历物品再遍历背包容量**，此时才能保证 dp[j] 的状态是只会按照物品顺序依次更新的（遍历物品 0，更新 dp[j]，遍历物品 1 ,再更新 dp[j]，能保证物品 1 的状态是在物品 0 之后的，也就变相保证了物品顺序只会有物品 0、物品 1 的放入方法）。
   - 如果是排列问题（即物品放入顺序不同属于不同方法），则**需要先遍历背包容量再遍历物品**，根据背包容量 j 的逐渐增大，物品会频繁多次放入，第一次容量为 0 时循环物品 0 状态在物品 1 前更新，但是从容量 1 开始，物品 1 也会去更新物品 0 的状态。（也就会有先放物品 0 后放物品 1，和先放物品 1 再放物品 0 的两种放入方法）。
4. 完全背包排列组合问题一维 DP 数组模版：

```js
// 1. 初始化一维dp数组
let dp = new Array(bagweight + 1).fill(0);
// 2. 考虑背包容量为 0，物品 0 个的情况
dp[0] = 1; // 不放任何物品时，放满背包的方法数为 1
// 3. 组合问题先遍历物品后遍历背包容量
for (let i = 0; i < weight.length; i++) { // 依次遍历物品，所以这里只会有先物品 0、物品 1 的放入顺序。不会有先物品 1、物品 0 的情况
   // 4. 遍历背包容量。注意排列问题先遍历背包时，下标应该从 0 开始（此时 weight[i]也是未确定的）。
   for (let j = weight[i]; j <= bagweight; j++) { 
      dp[j] += dp[j - weight[i]];
   }
}
```

#### 爬楼梯思维解决完全背包排列问题

1. 思维转变：我们要爬背包重量层楼梯，每次能爬的步数在物品中选择，判断最后爬到楼顶用多少中方式（或者能否爬到楼顶）。
2. 爬楼梯到达楼顶总方式递推公式： 在爬到第 `j - climb[i]` 层楼梯的前提下，我们再爬 `climb[i]` 步即可到达楼顶。所以 `dp[j]` 的状态依赖于 `dp[j - climb[i]]` 的状态。我们需要考虑 `dp[0]` 的初始化，一般 `dp[0] = 1`，表示到达起始位置第 0 层的方式有 1 种，即不怕任何楼梯。此时递推公式为：`dp[j] += dp[j - climb[i]]`。
3. 爬楼梯能否到达楼顶递推公式：`dp[j] = dp[j - climb[i]]`。即在能爬到第 `j - climb[i]` 层楼梯的前提下，我们再爬 `weight[i]` 步即可到达楼顶。
4. 爬楼梯问题一维 DP 数组模版：

```js
// 1. 初始化一维dp数组，到达楼顶位置为 stairs +1，如果是能否抵达问题。则要初始化为 false
let dp = new Array(stairs + 1).fill(0);
// 2. 考虑在初始位置 0 层的情况 ，如果是能否抵达问题，则dp[0]初始化为 true
dp[0] = 1; // 不爬即可抵达为 1 种方法
// 3. 遍历楼梯
for (let j = 0; j <= stairs; j++) { // 遍历每个楼梯
   // 4. 遍历每次可以爬的步数 climb[i]
   for (let i = 0; i < climb.length; j++) { 
      let climb = climb[i]; // 当前爬的步数
      if (j <= climb) continue; // 如果当前楼梯层数小于爬的步数，则不能到达
      dp[j] += dp[j - climb[i]]; // 爬到第 j 层楼梯的方式等于爬到第 j - climb[i] 层楼梯的方式

      // 楼顶能否抵达问题：
      // if (!dp[j - climb[i]]) continue; // 如果前面楼梯没有到达方式，则不能到达当前层
      // dp[j] = dp[j - climb[i]]; // 如果前面楼梯有到达方式，则当前层楼梯的方式等于前面楼梯的方式
   }
}

return dp[stairs]; // 返回到达楼顶的方式 or 能否到达楼顶
```
